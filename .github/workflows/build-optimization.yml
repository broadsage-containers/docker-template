# SPDX-FileCopyrightText: Copyright (c) 2025 Broadsage <opensource@broadsage.com>
#
# SPDX-License-Identifier: Apache-2.0

---
name: "[Build] Advanced Container Optimization"

on:
  workflow_dispatch:
    inputs:
      container_filter:
        description: "Comma-separated list of containers to optimize"
        required: false
        type: string
      optimization_type:
        description: "Type of optimization to perform"
        required: true
        type: choice
        options:
          - size-analysis
          - multi-stage-optimization
          - base-image-analysis
          - security-hardening
          - all
      create_pr:
        description: "Create PR with optimization recommendations"
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  pull-requests: write
  issues: write

env:
  REGISTRY: ghcr.io

concurrency:
  group: build-optimization-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  discover-containers:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.generate-matrix.outputs.matrix }}
      has_containers: ${{ steps.generate-matrix.outputs.has_containers }}
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@ec9f2d5744a09debf3a187a3f4f675c53b671911 # v2.13.0
        with:
          egress-policy: audit

      - name: Checkout Repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Generate container matrix
        id: generate-matrix
        env:
          CONTAINER_FILTER: ${{ github.event.inputs.container_filter }}
        run: |
          set -euo pipefail

          # Initialize containers array
          containers=()

          if [[ -n "${CONTAINER_FILTER:-}" ]]; then
            echo "Using container filter: ${CONTAINER_FILTER}"
            IFS=',' read -ra FILTER_ARRAY <<< "${CONTAINER_FILTER}"
            for filter in "${FILTER_ARRAY[@]}"; do
              mapfile -t found_containers < <(find library -name "Dockerfile" -type f | grep -E "library/${filter}/[^/]+/[^/]+/Dockerfile$" | sed 's|/Dockerfile||g' | sort)
              containers+=("${found_containers[@]}")
            done
          else
            echo "Discovering all containers for optimization"
            mapfile -t containers < <(find library -name "Dockerfile" -type f | grep -E "library/[^/]+/[^/]+/[^/]+/Dockerfile$" | sed 's|/Dockerfile||g' | sort)
          fi

          if [ ${#containers[@]} -gt 0 ]; then
            matrix_json=$(printf '%s\n' "${containers[@]}" | jq -R . | jq -s .)
            echo "matrix=${matrix_json}" >> "$GITHUB_OUTPUT"
            echo "has_containers=true" >> "$GITHUB_OUTPUT"
            
            echo "Found containers for optimization:"
            printf '%s\n' "${containers[@]}"
          else
            echo "No containers found for optimization"
            echo "matrix=[]" >> "$GITHUB_OUTPUT" 
            echo "has_containers=false" >> "$GITHUB_OUTPUT"
          fi

  analyze-containers:
    runs-on: ubuntu-latest
    needs: discover-containers
    if: needs.discover-containers.outputs.has_containers == 'true'
    strategy:
      fail-fast: false
      max-parallel: 3
      matrix:
        container: ${{ fromJson(needs.discover-containers.outputs.matrix) }}
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@ec9f2d5744a09debf3a187a3f4f675c53b671911 # v2.13.0
        with:
          egress-policy: audit

      - name: Checkout Repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1

      - name: Container Size Analysis
        if: inputs.optimization_type == 'size-analysis' || inputs.optimization_type == 'all'
        run: |
          set -euo pipefail

          echo "ðŸ“ Analyzing container size for ${{ matrix.container }}"

          # Build container for analysis
          docker build -t temp-analysis:latest "${{ matrix.container }}" --progress=plain > build.log 2>&1 || true

          # Get image size
          if docker images temp-analysis:latest --format "table {{.Size}}" | tail -n +2 | head -1; then
            image_size=$(docker images temp-analysis:latest --format "{{.Size}}" | head -1)
            echo "ðŸ“Š Image size: $image_size"
            
            # Analyze layers
            echo "ðŸ§… Layer analysis:"
            docker history temp-analysis:latest --format "table {{.CreatedBy}}\t{{.Size}}" --no-trunc | head -10
            
            # Check for large files/directories
            echo "ðŸ” Checking for large files in container:"
            docker run --rm temp-analysis:latest sh -c '
              echo "Top 10 largest files/directories:"
              du -ah / 2>/dev/null | sort -rh | head -10 | grep -v "^du:"
            ' || echo "Could not analyze file sizes"
            
            # Cleanup
            docker rmi temp-analysis:latest || true
          else
            echo "âŒ Failed to build container for size analysis"
          fi

      - name: Multi-stage Build Analysis
        if: inputs.optimization_type == 'multi-stage-optimization' || inputs.optimization_type == 'all'
        run: |
          set -euo pipefail

          echo "ðŸ—ï¸ Analyzing multi-stage build opportunities for ${{ matrix.container }}"

          dockerfile="${{ matrix.container }}/Dockerfile"

          if [ -f "$dockerfile" ]; then
            echo "ðŸ“‹ Current Dockerfile structure:"
            grep -n "FROM\|RUN\|COPY\|ADD" "$dockerfile" | head -20
            
            # Check if already using multi-stage
            from_count=$(grep -c "^FROM" "$dockerfile" || echo "0")
            if [ "$from_count" -gt 1 ]; then
              echo "âœ… Already using multi-stage build ($from_count stages)"
            else
              echo "ðŸ’¡ Single-stage build detected - consider multi-stage optimization"
            fi
            
            # Look for optimization opportunities
            echo "ðŸ” Optimization opportunities:"
            
            # Check for package cache cleanup
            if grep -q "apt-get update" "$dockerfile" && ! grep -q "rm -rf /var/lib/apt/lists" "$dockerfile"; then
              echo "ðŸ’¡ Consider cleaning apt cache: RUN apt-get update && apt-get install -y ... && rm -rf /var/lib/apt/lists/*"
            fi
            
            # Check for unnecessary files
            if grep -q "curl\|wget" "$dockerfile"; then
              echo "ðŸ’¡ Consider using multi-stage to avoid including download tools in final image"
            fi
            
            # Check for development tools
            if grep -E "git|make|gcc|build-essential" "$dockerfile" >/dev/null; then
              echo "ðŸ’¡ Consider using multi-stage to exclude development tools from final image"
            fi
          else
            echo "âŒ Dockerfile not found: $dockerfile"
          fi

      - name: Base Image Analysis
        if: inputs.optimization_type == 'base-image-analysis' || inputs.optimization_type == 'all'
        run: |
          set -euo pipefail

          echo "ðŸ  Analyzing base image for ${{ matrix.container }}"

          dockerfile="${{ matrix.container }}/Dockerfile"

          if [ -f "$dockerfile" ]; then
            base_image=$(grep "^FROM" "$dockerfile" | head -1 | awk '{print $2}')
            echo "ðŸ“¦ Current base image: $base_image"
            
            # Analyze base image size
            docker pull "$base_image" || echo "Could not pull base image"
            if docker images "$base_image" --format "{{.Size}}" | head -1; then
              base_size=$(docker images "$base_image" --format "{{.Size}}" | head -1)
              echo "ðŸ“Š Base image size: $base_size"
            fi
            
            # Suggest alternatives
            echo "ðŸ’¡ Alternative base image suggestions:"
            case "$base_image" in
              *ubuntu*|*debian*)
                echo "  - Consider bitnami/minideb for smaller Debian-based images"
                echo "  - Consider distroless for minimal runtime images"
                ;;
              *alpine*)
                echo "  - Already using Alpine (good for size)"
                echo "  - Consider distroless for even more minimal images"
                ;;
              *scratch*)
                echo "  - Already using minimal scratch image"
                ;;
              *)
                echo "  - Consider Alpine or distroless alternatives"
                echo "  - Consider bitnami/minideb for Debian compatibility"
                ;;
            esac
          else
            echo "âŒ Dockerfile not found: $dockerfile"
          fi

      - name: Security Hardening Analysis
        if: inputs.optimization_type == 'security-hardening' || inputs.optimization_type == 'all'
        run: |
          set -euo pipefail

          echo "ðŸ”’ Analyzing security hardening for ${{ matrix.container }}"

          dockerfile="${{ matrix.container }}/Dockerfile"

          if [ -f "$dockerfile" ]; then
            echo "ðŸ” Security analysis:"
            
            # Check for non-root user
            if grep -q "USER" "$dockerfile"; then
              echo "âœ… Non-root user configured"
            else
              echo "âš ï¸ Consider adding non-root user: USER 1001"
            fi
            
            # Check for HEALTHCHECK
            if grep -q "HEALTHCHECK" "$dockerfile"; then
              echo "âœ… Health check configured"
            else
              echo "ðŸ’¡ Consider adding HEALTHCHECK instruction"
            fi
            
            # Check for unnecessary setuid binaries
            echo "ðŸ” Checking for potential security issues..."
            docker build -t temp-security:latest "${{ matrix.container }}" --progress=plain >/dev/null 2>&1 || true
            if docker images temp-security:latest --format "{{.ID}}" | head -1 >/dev/null; then
              docker run --rm temp-security:latest sh -c '
                echo "Checking for setuid binaries:"
                find / -perm /4000 -type f 2>/dev/null | head -5
              ' || echo "Could not analyze setuid binaries"
              
              docker rmi temp-security:latest || true
            fi
            
            # Check for secrets in environment variables
            if grep -i "password\|secret\|key.*=" "$dockerfile"; then
              echo "âš ï¸ Potential secrets detected in Dockerfile - use build secrets instead"
            fi
          else
            echo "âŒ Dockerfile not found: $dockerfile"
          fi

      - name: Generate Optimization Report
        run: |
          set -euo pipefail

          echo "ðŸ“Š Container Optimization Report for ${{ matrix.container }}"
          echo "============================================================"
          echo "Date: $(date)"
          echo "Optimization Type: ${{ inputs.optimization_type }}"
          echo ""
          echo "This analysis completed successfully."
          echo "Check the logs above for specific recommendations."

          # Save report as artifact
          mkdir -p optimization-reports
          cat > "optimization-reports/${{ matrix.container }}-report.txt" <<EOF
          Container: ${{ matrix.container }}
          Date: $(date)
          Optimization Type: ${{ inputs.optimization_type }}
          Status: Analysis completed

          See GitHub Actions logs for detailed recommendations.
          EOF

      - name: Upload Optimization Reports
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        if: always()
        with:
          name: optimization-report-${{ matrix.container }}
          path: optimization-reports/
          retention-days: 30

  summarize-results:
    runs-on: ubuntu-latest
    needs: [discover-containers, analyze-containers]
    if: always() && needs.discover-containers.outputs.has_containers == 'true'
    steps:
      - name: Download All Reports
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4.1.8
        with:
          pattern: optimization-report-*
          merge-multiple: true

      - name: Generate Summary Report
        run: |
          echo "ðŸ“Š Container Optimization Summary"
          echo "================================"
          echo "Date: $(date)"
          echo "Optimization Type: ${{ inputs.optimization_type }}"
          echo "Containers Analyzed: $(find . -name "*-report.txt" | wc -l)"
          echo ""

          echo "Individual Reports:"
          for report in *-report.txt; do
            if [ -f "$report" ]; then
              echo "- $report"
            fi
          done

          echo ""
          echo "âœ… Container optimization analysis completed!"
          echo "Check individual job logs for detailed recommendations."
