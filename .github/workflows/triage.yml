# SPDX-FileCopyrightText: Copyright (c) 2025 Broadsage <opensource@broadsage.com>
#
# SPDX-License-Identifier: Apache-2.0

---
name: "[Support] Enhanced Issue and PR Triage"

on:
  issues:
    types: [opened, edited, labeled, unlabeled]
  pull_request:
    types: [opened, edited, labeled, unlabeled, ready_for_review]
  schedule:
    # Run triage check every 6 hours
    - cron: "0 */6 * * *"
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Specific issue number to triage (optional)"
        required: false
        type: string
      action_type:
        description: "Type of management action"
        required: false
        default: "all"
        type: choice
        options:
          - "triage"
          - "labeling"
          - "routing"
          - "all"

# Use restrictive default permissions
permissions:
  contents: read

jobs:
  # PR Title Validation for Conventional Commits
  validate-pr-title:
    runs-on: ubuntu-latest
    name: Validate PR Title Format
    if: |
      github.event.pull_request &&
      (github.event.action == 'opened' || github.event.action == 'edited') &&
      github.actor != 'dependabot[bot]' &&
      github.actor != 'github-actions[bot]'
    permissions:
      contents: read
      pull-requests: write
      checks: write
      statuses: write
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@ec9f2d5744a09debf3a187a3f4f675c53b671911 # v2.13.0
        with:
          egress-policy: audit

      - name: Validate PR Title Convention
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          github-token: ${{ secrets.AUTOBOT_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const title = context.payload.pull_request.title.trim().replace(/\s+/g, ' ');
            const conventionalCommitPattern = /^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(\(.+\))?!?:\s.+/;
            const isValid = conventionalCommitPattern.test(title);

            console.log(`üîç Validating PR title: "${title}"`);
            console.log(`üìù Original PR title: "${context.payload.pull_request.title}"`);
            console.log(`‚úÖ Valid format: ${isValid}`);

            if (!isValid) {
              const commentBody = `## ‚ùå PR Title Format Issue

            Hello! üëã Your PR title doesn't follow our conventional commit format.

            ### üìã Required Format:
            \`<type>[optional scope]: <description>\`

            ### üéØ Valid Types:
            - \`feat\`: New features
            - \`fix\`: Bug fixes  
            - \`docs\`: Documentation changes
            - \`style\`: Code style changes (formatting, etc.)
            - \`refactor\`: Code refactoring
            - \`perf\`: Performance improvements
            - \`test\`: Test changes
            - \`chore\`: Maintenance tasks
            - \`ci\`: CI/CD changes
            - \`build\`: Build system changes
            - \`revert\`: Revert changes

            ### üéØ Common Scopes (optional):
            - \`api\`: API changes, endpoints
            - \`auth\`: Authentication, authorization
            - \`build\`: Build system, compilation
            - \`ci\`: CI/CD workflows
            - \`config\`: Configuration files
            - \`container\`: Container-related changes
            - \`deps\`: Dependencies, packages
            - \`docker\`: Docker-specific changes
            - \`docs\`: Documentation
            - \`nginx\`: Nginx-specific changes
            - \`scripts\`: Build/automation scripts
            - \`security\`: Security-related changes
            - \`test\`: Testing code
            - \`workflow\`: GitHub Actions workflows

            ### üìù Examples:
            - \`feat: add nginx 1.29 support\`
            - \`fix(docker): resolve build issue\`  
            - \`feat(api): add container registry endpoint\`
            - \`chore(deps): bump nginx to 1.29.1\`
            - \`fix(security): patch CVE-2024-1234\`
            - \`feat(auth)!: breaking authentication changes\`

            ### üîß Please update your PR title to match this format.

            **Original title:** \`${context.payload.pull_request.title}\`
            **Processed title:** \`${title}\`

            *Note: Whitespace and newlines are normalized for validation. This helps us automatically apply the correct labels and maintain a clean commit history!* ‚ú®`;

              // Add a comment explaining the requirements
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: commentBody
              });

              // Set status check to failed
              await github.rest.repos.createCommitStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                sha: context.payload.pull_request.head.sha,
                state: 'failure',
                context: 'pr-title-validation',
                description: 'PR title must follow conventional commit format'
              });
              
              core.setFailed('PR title does not follow conventional commit format');
            } else {
              // Set status check to success
              await github.rest.repos.createCommitStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                sha: context.payload.pull_request.head.sha,
                state: 'success',
                context: 'pr-title-validation',
                description: 'PR title follows conventional commit format ‚úÖ'
              });
              
              console.log('‚úÖ PR title validation passed');
            }

  # Auto-labeling for new issues and PRs
  auto-label:
    runs-on: ubuntu-latest
    name: Auto-label issues and PRs
    if: |
      (github.event.action == 'opened') &&
      (github.event.inputs.action_type == 'labeling' || 
       github.event.inputs.action_type == 'all' ||
       github.event_name != 'workflow_dispatch') &&
      github.actor != 'dependabot[bot]' &&
      github.actor != 'github-actions[bot]'
    permissions:
      contents: read
      issues: write
      pull-requests: write
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@ec9f2d5744a09debf3a187a3f4f675c53b671911 # v2.13.0
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7

      - name: Auto-label based on content
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        if: github.actor != 'dependabot[bot]'
        continue-on-error: true
        with:
          github-token: ${{ secrets.AUTOBOT_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            // Load auto-label configuration
            const configPath = path.join(process.env.GITHUB_WORKSPACE, '.github', 'auto-label-config.json');
            let config;

            try {
              const configContent = fs.readFileSync(configPath, 'utf8');
              config = JSON.parse(configContent);
              console.log('üìÑ Loaded auto-label configuration from auto-label-config.json');
              console.log(`üìä Config version: ${config._version || 'unknown'}`);
            } catch (error) {
              console.log(`‚ùå Error loading config file: ${error.message}`);
              console.log('üîÑ Falling back to basic conventional commits logic');
              
              // Fallback to basic conventional commits logic
              config = {
                enabled: true,
                max_labels: 3,
                conventional_commits: {
                  'feat': { label: 'type: feature', priority: 1 },
                  'fix': { label: 'type: fix', priority: 1 },
                  'docs': { label: 'type: docs', priority: 2 },
                  'chore': { label: 'type: chore', priority: 3 }
                },
                breaking_changes: {
                  label: 'breaking-change',
                  patterns: ['!:', 'BREAKING CHANGE:', 'BREAKING-CHANGE:'],
                  priority: 1
                },
                scopes: {
                  'docker': { label: 'scope: docker', priority: 2 },
                  'container': { label: 'scope: container', priority: 2 },
                  'security': { label: 'scope: security', priority: 1 }
                }
              };
            }

            // Check if auto-labeling is enabled
            if (!config.enabled) {
              console.log('‚è∏Ô∏è Auto-labeling is disabled in configuration');
              return;
            }

            const issue = context.payload.issue || context.payload.pull_request;
            const isIssue = !!context.payload.issue;
            const title = issue.title;
            const body = issue.body || '';
            const labels = [];
            const maxLabels = config.max_labels || 3;

            console.log(`üîç Analyzing ${isIssue ? 'issue' : 'PR'}: "${title}"`);

            // Enhanced conventional commit detection for PRs
            if (!isIssue) {
              const conventionalCommitPattern = /^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(\(([^)]+)\))?(!)?:\s*(.+)/;
              const match = title.match(conventionalCommitPattern);
              
              if (match) {
                const [, commitType, , scope, breakingChange, description] = match;
                
                console.log(`‚úÖ Detected conventional commit - Type: "${commitType}"${scope ? `, Scope: "${scope}"` : ''}${breakingChange ? ', Breaking: true' : ''}`);
                
                // Apply type label using new configuration format
                if (config.conventional_commits && config.conventional_commits[commitType]) {
                  const typeConfig = config.conventional_commits[commitType];
                  labels.push(typeConfig.label);
                  console.log(`üè∑Ô∏è Applied type label: "${typeConfig.label}"`);
                }
                
                // Apply scope label if scope is present
                if (scope && config.scopes && config.scopes[scope.toLowerCase()]) {
                  const scopeConfig = config.scopes[scope.toLowerCase()];
                  labels.push(scopeConfig.label);
                  console.log(`üéØ Applied scope label: "${scopeConfig.label}" for scope "${scope}"`);
                }
                
                // Check for breaking changes
                if (breakingChange || 
                    config.breaking_changes?.patterns?.some(pattern => 
                      title.includes(pattern) || body.includes(pattern))) {
                  if (config.breaking_changes?.label) {
                    labels.push(config.breaking_changes.label);
                    console.log(`‚ö†Ô∏è Applied breaking change label: "${config.breaking_changes.label}"`);
                  }
                }
              } else {
                console.log('‚ö†Ô∏è PR title does not follow conventional commit format');
                console.log('üí° Expected format: type(scope): description or type: description');
              }
            } else {
              // For issues, we can still try to detect conventional commit patterns or use basic keyword matching
              console.log('üìù Issue detected - applying basic content analysis');
              
              const titleLower = title.toLowerCase();
              const bodyLower = body.toLowerCase();
              
              // Basic keyword detection for issues
              if (titleLower.includes('bug') || titleLower.includes('fix') || titleLower.includes('error')) {
                if (config.conventional_commits?.fix) {
                  labels.push(config.conventional_commits.fix.label);
                  console.log('üêõ Applied fix label for issue containing bug-related keywords');
                }
              } else if (titleLower.includes('feature') || titleLower.includes('enhancement')) {
                if (config.conventional_commits?.feat) {
                  labels.push(config.conventional_commits.feat.label);
                  console.log('‚ú® Applied feature label for issue containing feature-related keywords');
                }
              } else if (titleLower.includes('documentation') || titleLower.includes('docs')) {
                if (config.conventional_commits?.docs) {
                  labels.push(config.conventional_commits.docs.label);
                  console.log('üìö Applied docs label for issue containing documentation-related keywords');
                }
              }
              
              // Check for security-related content
              if (titleLower.includes('security') || titleLower.includes('vulnerability') || 
                  bodyLower.includes('security') || bodyLower.includes('cve')) {
                if (config.scopes?.security) {
                  labels.push(config.scopes.security.label);
                  console.log('üîí Applied security scope label');
                }
              }
            }

            // Remove duplicates and sort by priority
            const uniqueLabels = [...new Set(labels)];

            // Sort labels by priority if we have the config structure
            const sortedLabels = uniqueLabels.sort((a, b) => {
              let priorityA = 999, priorityB = 999;
              
              // Find priority from config
              for (const [type, typeConfig] of Object.entries(config.conventional_commits || {})) {
                if (typeConfig.label === a) priorityA = typeConfig.priority || 999;
                if (typeConfig.label === b) priorityB = typeConfig.priority || 999;
              }
              for (const [scope, scopeConfig] of Object.entries(config.scopes || {})) {
                if (scopeConfig.label === a) priorityA = scopeConfig.priority || 999;
                if (scopeConfig.label === b) priorityB = scopeConfig.priority || 999;
              }
              if (config.breaking_changes?.label === a) priorityA = config.breaking_changes.priority || 1;
              if (config.breaking_changes?.label === b) priorityB = config.breaking_changes.priority || 1;
              
              return priorityA - priorityB;
            });

            const finalLabels = sortedLabels.slice(0, maxLabels);

            console.log(`üìã Final labels to apply: [${finalLabels.join(', ')}]`);

            if (uniqueLabels.length > maxLabels) {
              console.log(`‚ö†Ô∏è Truncated ${uniqueLabels.length - maxLabels} labels due to safety limit (max: ${maxLabels})`);
            }

            // Apply labels to the issue/PR
            if (finalLabels.length > 0) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: finalLabels
                });
                console.log(`‚úÖ Successfully applied ${finalLabels.length} labels: [${finalLabels.join(', ')}]`);
              } catch (error) {
                console.log(`‚ùå Error applying labels: ${error.message}`);
                console.log('üîç Some labels might not exist in the repository yet');
                
                // Try to apply labels one by one to see which ones fail
                for (const label of finalLabels) {
                  try {
                    await github.rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      labels: [label]
                    });
                    console.log(`‚úÖ Applied label: "${label}"`);
                  } catch (singleError) {
                    console.log(`‚ùå Failed to apply label "${label}": ${singleError.message}`);
                  }
                }
              }
            } else {
              console.log('‚ÑπÔ∏è No labels to apply based on configuration rules');
            }

  # Intelligent routing
  intelligent-routing:
    runs-on: ubuntu-latest
    name: Route issues intelligently
    if: |
      (github.event.action == 'opened') &&
      (github.event.inputs.action_type == 'routing' || 
       github.event.inputs.action_type == 'all' ||
       github.event_name != 'workflow_dispatch') &&
      github.actor != 'dependabot[bot]' &&
      github.actor != 'github-actions[bot]'
    permissions:
      issues: write
      pull-requests: write
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@ec9f2d5744a09debf3a187a3f4f675c53b671911 # v2.13.0
        with:
          egress-policy: audit

      - name: Route to appropriate teams
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        if: github.actor != 'dependabot[bot]'
        with:
          script: |
            const issue = context.payload.issue || context.payload.pull_request;
            const title = issue.title.toLowerCase();
            const body = (issue.body || '').toLowerCase();

            // Skip template content
            const templateIndicators = ['container name(s):', 'version(s):', 'fill in details'];
            if (templateIndicators.some(indicator => body.includes(indicator.toLowerCase()))) {
              console.log('üö´ Template content detected, skipping routing');
              return;
            }

            // Conservative routing rules (very specific to avoid false positives)
            const routingRules = {
              security: {
                keywords: ['security vulnerability', 'cve-', 'security exploit', 'security issue'],
                labels: ['security', 'priority-high'],
                message: 'üîí **Security Issue** - This has been escalated to the security team.'
              },
              containers: {
                keywords: ['dockerfile bug', 'container fails', 'docker build error', 'image build issue'],
                labels: ['area/containers'],
                message: 'üê≥ **Container Issue** - The containers team has been notified.'
              }
            };

            for (const [category, rule] of Object.entries(routingRules)) {
              if (rule.keywords.some(keyword => title.includes(keyword) || body.includes(keyword))) {
                // Check if we already have this label to avoid duplicates
                const hasLabel = issue.labels.some(label => rule.labels.includes(label.name));
                if (!hasLabel) {
                  // Note: Labels are now handled by auto-label job, just add comment for routing
                  console.log(`üéØ Routing to ${category} team (labels handled by auto-label job)`);

                  // Check if we already commented to avoid spam
                  const { data: comments } = await github.rest.issues.listComments({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number
                  });

                  const hasRoutingComment = comments.some(comment => 
                    comment.user.login === 'github-actions[bot]' && 
                    (comment.body.includes('Security Issue') || comment.body.includes('Container Issue'))
                  );

                  if (!hasRoutingComment) {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: rule.message
                    });
                  }
                }
                break;
              }
            }

  # Main triage job
  triage:
    runs-on: ubuntu-latest
    name: Enhanced triage processing
    if: |
      github.event.inputs.action_type == 'triage' || 
      github.event.inputs.action_type == 'all' ||
      github.event_name == 'schedule' ||
      (github.event_name == 'workflow_dispatch' && 
       github.event.inputs.action_type != 'labeling' && 
       github.event.inputs.action_type != 'routing') ||
      (github.event_name == 'issues' && github.event.action != 'opened') ||
      (github.event_name == 'pull_request' && github.event.action != 'opened')
    # Job-level permissions for triage operations
    permissions:
      issues: write
      pull-requests: write
      contents: read
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@ec9f2d5744a09debf3a187a3f4f675c53b671911 # v2.13.0
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Validate issue template compliance
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        if: github.event_name == 'issues' && github.event.action == 'opened'
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const title = issue.title;
            const labels = [];

            // Check if issue follows template structure
            const hasEnvironmentSection = body.includes('Environment') || body.includes('environment');
            const hasStepsToReproduce = body.includes('Steps') || body.includes('reproduce');
            const hasExpectedBehavior = body.includes('Expected') || body.includes('expected');

            // Validate bug reports
            if (title.toLowerCase().includes('bug') || title.toLowerCase().includes('fix') || 
                body.toLowerCase().includes('bug') || body.toLowerCase().includes('error')) {
              if (!hasEnvironmentSection || !hasStepsToReproduce || !hasExpectedBehavior) {
                labels.push('status: needs-info');
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: `üëã Thanks for reporting this issue! 

                  It looks like this might be a bug report, but some important information is missing. To help us investigate efficiently, please provide:

                  **Missing Information:**
                  ${!hasEnvironmentSection ? '- üñ•Ô∏è **Environment details** (OS, Docker version, architecture)' : ''}
                  ${!hasStepsToReproduce ? '- üìù **Clear steps to reproduce** the issue' : ''}
                  ${!hasExpectedBehavior ? '- ‚úÖ **Expected behavior** description' : ''}

                  You can edit your issue description to add this information. Once provided, a maintainer will review your issue promptly.

                  **Tip:** Using our [issue templates](.github/ISSUE_TEMPLATE) helps ensure all necessary information is included! üìù`
                });
              } else {
                // Complete bug report gets ready status
                labels.push('status: ready');
              }
            }

            // Check for incomplete issues
            if (body.length < 50 || title.length < 10) {
              labels.push('status: needs-info');
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `üìù **More information needed**

                Your issue appears to be quite brief. To help us assist you effectively, please provide:

                - üìÑ A clear and detailed description of the issue
                - üéØ What you're trying to achieve
                - üîç What you've already tried
                - üì± Your environment details

                The more context you provide, the better we can help! üôå`
              });
            }

            // Apply labels if any
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: labels
              });
            }

      - name: Triage pull requests
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        if: github.event_name == 'pull_request' && github.actor != 'dependabot[bot]'
        with:
          script: |
            const pr = context.payload.pull_request;
            const body = pr.body || '';
            const title = pr.title;
            const labels = [];
            const comments = [];

            // Check PR description completeness
            const hasDescription = body.length > 50;
            const hasRelatedIssue = body.includes('#') || body.includes('fixes') || body.includes('closes');
            const hasTestingInfo = body.includes('test') || body.includes('Test');
            const hasChangeType = body.includes('- [x]') || body.includes('- [X]');

            if (!hasDescription) {
              labels.push('needs-info');
              comments.push(`üìù **PR Description Needed**
              
              Please provide a detailed description of your changes. A good PR description should include:
              - üéØ What problem this solves
              - üîß What changes were made
              - üß™ How it was tested
              - üìã Any breaking changes or special considerations`);
            }

            if (!hasRelatedIssue && !pr.title.toLowerCase().includes('chore')) {
              comments.push(`üîó **Link to Issue**
              
              Please link this PR to a related issue using keywords like:
              - \`Fixes #123\`
              - \`Closes #123\`
              - \`Resolves #123\`
              
              If no issue exists, consider creating one first to discuss the changes! üí≠`);
            }

            // Check for large PRs
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });

            const totalChanges = files.reduce((sum, file) => sum + file.additions + file.deletions, 0);

            if (totalChanges > 500) {
              // Note: large-pr label handled by auto-label job, just add to comments
              comments.push(`üìè **Large PR Detected**
              
              This PR has ${totalChanges} lines of changes. Large PRs can be harder to review effectively.
              
              Consider:
              - üî™ Breaking it into smaller, focused PRs
              - üìù Adding extra documentation for complex changes
              - üß™ Ensuring comprehensive testing
              
              If this size is necessary, please explain why in the PR description. ü§î`);
            }

            // Check for missing tests (if not docs/config only)
            const hasCodeChanges = files.some(file => 
              file.filename.match(/\.(js|ts|py|go|java|cpp|c|rs|php)$/));
            const hasTestChanges = files.some(file => 
              file.filename.includes('test') || file.filename.includes('spec'));

            if (hasCodeChanges && !hasTestChanges && !pr.title.toLowerCase().includes('docs')) {
              // Note: needs-tests label handled by auto-label job, just add to comments
              comments.push(`üß™ **Tests Recommended**
              
              This PR modifies code but doesn't appear to include tests. Consider adding:
              - ‚úÖ Unit tests for new functionality
              - üîç Integration tests if applicable
              - üìù Update existing tests if behavior changed
              
              If tests aren't needed, please explain why in the PR description. ü§ì`);
            }

            // Post combined comment if there are suggestions (no labels added by this job)
            if (comments.length > 0) {
              // Check if we already posted a triage comment to avoid duplicates
              const { data: existingComments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number
              });

              const hasTriageComment = existingComments.some(comment => 
                comment.user.login === 'github-actions[bot]' && 
                comment.body.includes('Automated PR Triage')
              );

              if (!hasTriageComment) {
                const combinedComment = `üëã **Automated PR Triage**

                ${comments.join('\n\n---\n\n')}

                ---
                
                üí° **Tips for faster review:**
                - Use our [PR template](.github/PULL_REQUEST_TEMPLATE.md)
                - Keep PRs focused and small when possible
                - Include tests and documentation updates
                - Link to related issues
                
                Thanks for contributing! üôè`;
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  body: combinedComment
                });
                console.log('‚úÖ Posted triage comment (no labels added)');
              } else {
                console.log('‚è≠Ô∏è Triage comment already exists, skipping');
              }
            }

      - name: Prioritize critical issues
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        if: github.event_name == 'issues'
        with:
          script: |
            const issue = context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = (issue.body || '').toLowerCase();
            const labels = [];

            // Critical issue keywords
            const criticalKeywords = [
              'critical', 'urgent', 'production', 'outage', 'down', 'broken',
              'security', 'vulnerability', 'exploit', 'cve', 'data loss'
            ];

            const highPriorityKeywords = [
              'regression', 'breaking', 'blocker', 'severe', 'major'
            ];

            // Check for critical issues
            if (criticalKeywords.some(keyword => title.includes(keyword) || body.includes(keyword))) {
              labels.push('priority-critical');
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `üö® **Critical Issue Detected**

                This issue has been automatically flagged as critical priority based on its content.
                
                **Immediate Actions:**
                - üîî Maintainers have been notified
                - ‚ö° This will be triaged with highest priority
                - üìû For urgent production issues, consider reaching out via our support channels
                
                **Next Steps:**
                - A maintainer will review within 24 hours
                - Please ensure all critical information is provided
                - Monitor for updates and respond promptly to questions
                
                Thank you for the detailed report! üôè`
              });
            } else if (highPriorityKeywords.some(keyword => title.includes(keyword) || body.includes(keyword))) {
              labels.push('priority-high');
            }

            // Apply priority labels
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: labels
              });
            }

      - name: Community health check
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        if: github.event_name == 'schedule'
        with:
          script: |
            // Find issues that need maintainer attention
            const { data: needsTriageIssues } = await github.rest.search.issuesAndPullRequests({
              q: `repo:${context.repo.owner}/${context.repo.repo} is:open is:issue -label:triaged -label:wontfix -label:duplicate created:>=${new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]}`,
              sort: 'created',
              order: 'desc',
              per_page: 10
            });

            // Find old issues without response
            const { data: staleIssues } = await github.rest.search.issuesAndPullRequests({
              q: `repo:${context.repo.owner}/${context.repo.repo} is:open is:issue comments:0 created:<${new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]}`,
              per_page: 5
            });

            if (needsTriageIssues.total_count > 0 || staleIssues.total_count > 0) {
              console.log(`üìä Triage Report:
              - ${needsTriageIssues.total_count} recent issues need triage
              - ${staleIssues.total_count} older issues have no responses
              `);
              
              // Add triage-needed label to untriaged issues
              for (const issue of needsTriageIssues.items) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['triage-needed']
                });
              }
            }

      - name: Update triage metrics
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        if: github.event_name == 'schedule'
        with:
          script: |
            // Generate triage statistics
            const now = new Date();
            const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

            const queries = {
              'new_issues': `repo:${context.repo.owner}/${context.repo.repo} is:issue created:>=${oneWeekAgo.toISOString().split('T')[0]}`,
              'new_prs': `repo:${context.repo.owner}/${context.repo.repo} is:pr created:>=${oneWeekAgo.toISOString().split('T')[0]}`,
              'triaged_issues': `repo:${context.repo.owner}/${context.repo.repo} is:issue label:triaged created:>=${oneWeekAgo.toISOString().split('T')[0]}`,
              'needs_triage': `repo:${context.repo.owner}/${context.repo.repo} is:open is:issue -label:triaged -label:wontfix`,
              'critical_open': `repo:${context.repo.owner}/${context.repo.repo} is:open is:issue label:priority-critical`
            };

            const stats = {};
            for (const [key, query] of Object.entries(queries)) {
              const { data } = await github.rest.search.issuesAndPullRequests({ q: query, per_page: 1 });
              stats[key] = data.total_count;
            }

            console.log(`üìà Weekly Triage Metrics:
            üì• New Issues: ${stats.new_issues}
            üîÑ New PRs: ${stats.new_prs}  
            ‚úÖ Triaged: ${stats.triaged_issues}
            ‚è≥ Needs Triage: ${stats.needs_triage}
            üö® Critical Open: ${stats.critical_open}

            üìä Triage Rate: ${stats.new_issues > 0 ? Math.round((stats.triaged_issues / stats.new_issues) * 100) : 0}%
            `);

            // Create issue if triage backlog is high
            if (stats.needs_triage > 20) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `üè• Triage Backlog Alert: ${stats.needs_triage} issues need attention`,
                body: `## Triage Backlog Alert

                Our issue triage backlog has grown to **${stats.needs_triage} issues** that need maintainer attention.

                ### Weekly Stats:
                - üì• New Issues: ${stats.new_issues}
                - ‚úÖ Triaged: ${stats.triaged_issues}
                - ‚è≥ Pending Triage: ${stats.needs_triage}
                - üö® Critical Issues: ${stats.critical_open}

                ### Recommended Actions:
                - [ ] Review [untriaged issues](https://github.com/${context.repo.owner}/${context.repo.repo}/issues?q=is%3Aopen+is%3Aissue+-label%3Atriaged+-label%3Awontfix)
                - [ ] Add appropriate labels and priority
                - [ ] Close duplicate or invalid issues
                - [ ] Assign issues to milestones if applicable

                This alert was automatically generated by our triage workflow.`,
                labels: ['triage-needed', 'maintenance']
              });
            }
