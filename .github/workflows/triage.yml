# SPDX-FileCopyrightText: Copyright (c) 2025 Broadsage <opensource@broadsage.com>
#
# SPDX-License-Identifier: Apache-2.0

---
name: "[Support] Enhanced Issue and PR Triage"

on:
  issues:
    types: [opened, edited, labeled, unlabeled]
  pull_request:
    types: [opened, edited, labeled, unlabeled, ready_for_review]
  schedule:
    # Run triage check every 6 hours
    - cron: "0 */6 * * *"
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Specific issue number to triage (optional)"
        required: false
        type: string
      action_type:
        description: "Type of management action"
        required: false
        default: "all"
        type: choice
        options:
          - "triage"
          - "labeling"
          - "routing"
          - "all"

# Use restrictive default permissions
permissions:
  contents: read

jobs:
  # PR Title Validation for Conventional Commits
  validate-pr-title:
    runs-on: ubuntu-latest
    name: Validate PR Title Format
    if: |
      github.event.pull_request &&
      (github.event.action == 'opened' || github.event.action == 'edited') &&
      github.actor != 'dependabot[bot]' &&
      github.actor != 'github-actions[bot]'
    permissions:
      contents: read
      pull-requests: write
      checks: write
      statuses: write
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@v2
        with:
          egress-policy: audit

      - name: Validate PR Title Convention
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AUTOBOT_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const title = context.payload.pull_request.title.trim().replace(/\s+/g, ' ');
            const conventionalCommitPattern = /^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(\(.+\))?!?:\s.+/;
            const isValid = conventionalCommitPattern.test(title);

            console.log(`üîç Validating PR title: "${title}"`);
            console.log(`üìù Original PR title: "${context.payload.pull_request.title}"`);
            console.log(`‚úÖ Valid format: ${isValid}`);

            if (!isValid) {
              const commentBody = `## ‚ùå PR Title Format Issue

            Hello! üëã Your PR title doesn't follow our conventional commit format.

            ### üìã Required Format:
            \`<type>[optional scope]: <description>\`

            ### üéØ Valid Types:
            - \`feat\`: New features
            - \`fix\`: Bug fixes  
            - \`docs\`: Documentation changes
            - \`style\`: Code style changes (formatting, etc.)
            - \`refactor\`: Code refactoring
            - \`perf\`: Performance improvements
            - \`test\`: Test changes
            - \`chore\`: Maintenance tasks
            - \`ci\`: CI/CD changes
            - \`build\`: Build system changes

            ### üìù Examples:
            - \`feat: add nginx 1.29 support\`
            - \`fix(docker): resolve build issue\`  
            - \`docs: update README\`
            - \`refactor(workflow): consolidate actions\`
            - \`feat!: breaking API change\`

            ### üîß Please update your PR title to match this format.

            **Original title:** \`${context.payload.pull_request.title}\`
            **Processed title:** \`${title}\`

            *Note: Whitespace and newlines are normalized for validation. This helps us automatically apply the correct labels and maintain a clean commit history!* ‚ú®`;

              // Add a comment explaining the requirements
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: commentBody
              });

              // Set status check to failed
              await github.rest.repos.createCommitStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                sha: context.payload.pull_request.head.sha,
                state: 'failure',
                context: 'pr-title-validation',
                description: 'PR title must follow conventional commit format'
              });
              
              core.setFailed('PR title does not follow conventional commit format');
            } else {
              // Set status check to success
              await github.rest.repos.createCommitStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                sha: context.payload.pull_request.head.sha,
                state: 'success',
                context: 'pr-title-validation',
                description: 'PR title follows conventional commit format ‚úÖ'
              });
              
              console.log('‚úÖ PR title validation passed');
            }

  # Auto-labeling for new issues and PRs
  auto-label:
    runs-on: ubuntu-latest
    name: Auto-label issues and PRs
    if: |
      (github.event.action == 'opened') &&
      (github.event.inputs.action_type == 'labeling' || 
       github.event.inputs.action_type == 'all' ||
       github.event_name != 'workflow_dispatch') &&
      github.actor != 'dependabot[bot]' &&
      github.actor != 'github-actions[bot]'
    permissions:
      contents: read
      issues: write
      pull-requests: write
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@ec9f2d5744a09debf3a187a3f4f675c53b671911 # v2.13.0
        with:
          egress-policy: audit

      - name: Auto-label based on content
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        if: github.actor != 'dependabot[bot]'
        continue-on-error: true
        with:
          github-token: ${{ secrets.AUTOBOT_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue || context.payload.pull_request;
            const isIssue = !!context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = (issue.body || '').toLowerCase();
            const labels = [];

            console.log(`üîç Analyzing ${isIssue ? 'issue' : 'PR'}: "${issue.title}"`);

            // Fallback labeling function definition (must be defined before use)
            const applyFallbackLabeling = () => {
              console.log('üîÑ Applying fallback keyword-based labeling');
              
              const fallbackKeywords = {
                'type: bug': ['bug fix', 'fix bug', 'fixes bug', 'hotfix'],
                'type: feature': ['new feature', 'add feature', 'implement'],
                'type: maintenance': ['refactor', 'cleanup', 'update', 'upgrade', 'bump'],
                'type: docs': ['update docs', 'fix docs', 'documentation'],
                'area/containers': ['docker', 'container', 'dockerfile'],
                'area/build': ['workflow', 'ci', 'build', 'pipeline']
              };

              let fallbackApplied = 0;
              for (const [label, keywords] of Object.entries(fallbackKeywords)) {
                if (fallbackApplied < 2 && keywords.some(keyword => title.includes(keyword))) {
                  labels.push(label);
                  console.log(`üè∑Ô∏è Applied fallback label: "${label}"`);
                  fallbackApplied++;
                }
              }
            };

            // Conventional Commit based labeling (primary method for PRs)
            if (!isIssue) {
              const conventionalCommitPattern = /^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(\(.+\))?!?:\s/;
              const match = issue.title.match(conventionalCommitPattern);
              
              if (match) {
                const commitType = match[1];
                const scope = match[2] ? match[2].slice(1, -1) : null; // Remove parentheses
                
                console.log(`‚úÖ Detected conventional commit type: "${commitType}"${scope ? ` with scope: "${scope}"` : ''}`);
                
                // Map conventional commit types to labels
                const conventionalToLabels = {
                  'feat': 'type: feature',
                  'fix': 'type: bug', 
                  'docs': 'type: docs',
                  'style': 'type: maintenance',
                  'refactor': 'type: maintenance',
                  'perf': 'performance',
                  'test': 'type: maintenance',
                  'chore': 'type: maintenance', 
                  'ci': 'area/build',
                  'build': 'area/build',
                  'revert': 'type: maintenance'
                };

                if (conventionalToLabels[commitType]) {
                  labels.push(conventionalToLabels[commitType]);
                  console.log(`üè∑Ô∏è Applied conventional commit label: "${conventionalToLabels[commitType]}"`);
                }

                // Handle scopes for area labels
                if (scope) {
                  const scopeToAreaLabels = {
                    'docker': 'area/containers',
                    'container': 'area/containers', 
                    'containers': 'area/containers',
                    'dockerfile': 'area/containers',
                    'workflow': 'area/build',
                    'workflows': 'area/build',
                    'ci': 'area/build',
                    'build': 'area/build',
                    'docs': 'type: docs',
                    'security': 'security'
                  };

                  if (scopeToAreaLabels[scope.toLowerCase()]) {
                    const scopeLabel = scopeToAreaLabels[scope.toLowerCase()];
                    if (!labels.includes(scopeLabel)) {
                      labels.push(scopeLabel);
                      console.log(`üéØ Applied scope-based label: "${scopeLabel}"`);
                    }
                  }
                }

                // Check for breaking change indicator (!)
                if (issue.title.includes('!:')) {
                  labels.push('breaking-change');
                  console.log('‚ö†Ô∏è Applied breaking-change label');
                }

              } else {
                console.log('‚ö†Ô∏è PR title does not follow conventional commit format');
                // Fallback to keyword-based labeling for non-conventional titles
                applyFallbackLabeling();
              }
            }

            // For issues, use keyword-based labeling (much more conservative)
            if (isIssue) {
              const issueKeywords = {
                'type: bug': ['bug report', 'error occurred', 'issue with', 'problem with'],
                'type: feature': ['feature request', 'enhancement request', 'new feature'],
                'type: docs': ['documentation issue', 'docs update', 'readme issue'],
                'question': ['question about', 'how to', 'help with']
              };

              for (const [label, keywords] of Object.entries(issueKeywords)) {
                if (keywords.some(keyword => title.includes(keyword) || body.includes(keyword))) {
                  labels.push(label);
                  console.log(`üè∑Ô∏è Applied issue label: "${label}"`);
                  break; // Only one type label for issues
                }
              }
            }

            console.log(`üìã Final labels to apply: [${labels.join(', ')}]`);

            // Apply labels with safety limit
            const maxLabels = 3;
            const finalLabels = labels.slice(0, maxLabels);

            if (labels.length > maxLabels) {
              console.log(`‚ö†Ô∏è Truncated ${labels.length - maxLabels} labels due to safety limit`);
            }

            if (finalLabels.length > 0) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: finalLabels
                });
                console.log(`‚úÖ Successfully applied ${finalLabels.length} labels: [${finalLabels.join(', ')}]`);
              } catch (error) {
                console.log(`‚ùå Error applying labels: ${error.message}`);
              }
            } else {
              console.log('‚ÑπÔ∏è No labels to apply');
            }

            // Priority detection (very conservative - only for explicit urgent/critical)
            if (['urgent', 'critical priority'].some(phrase => title.includes(phrase) || body.includes(phrase))) {
              if (!labels.includes('priority-high')) {
                labels.push('priority-high');
                console.log('üö® Applied high priority label');
              }
            }

            // Special handling for PRs - check for additional contextual labels
            if (!isIssue) {
              try {
                const { data: files } = await github.rest.pulls.listFiles({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: issue.number
                });

                const totalChanges = files.reduce((sum, file) => sum + file.additions + file.deletions, 0);

                // Large PR detection (conservative threshold)
                if (totalChanges > 800) { // Increased threshold to be less aggressive
                  labels.push('large-pr');
                  console.log(`üìè Applied large-pr label for ${totalChanges} line changes`);
                }

                // Missing tests detection (only for clear code changes)
                const hasCodeChanges = files.some(file => 
                  file.filename.match(/\.(js|ts|py|go|java|cpp|c|rs|php)$/));
                const hasTestChanges = files.some(file => 
                  file.filename.includes('test') || file.filename.includes('spec'));

                if (hasCodeChanges && !hasTestChanges && 
                    !title.includes('docs') && !title.includes('refactor') && 
                    totalChanges > 100) { // Only for substantial code changes
                  labels.push('needs-tests');
                  console.log('üß™ Applied needs-tests label for code changes without tests');
                }
              } catch (error) {
                console.log('Could not analyze PR files:', error.message);
              }
            }

            // Final safety check - limit total auto-applied labels to 3
            if (labels.length > 3) {
              console.log(`‚ö†Ô∏è Too many labels (${labels.length}), keeping only first 3`);
              labels.splice(3);
            }

            if (labels.length > 0) {
              console.log(`üè∑Ô∏è Applying ${labels.length} labels:`, labels.join(', '));
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: labels
              });
            } else {
              console.log('‚ÑπÔ∏è No auto-labels applied - PR did not match specific criteria');
            }

  # Intelligent routing
  intelligent-routing:
    runs-on: ubuntu-latest
    name: Route issues intelligently
    if: |
      (github.event.action == 'opened') &&
      (github.event.inputs.action_type == 'routing' || 
       github.event.inputs.action_type == 'all' ||
       github.event_name != 'workflow_dispatch') &&
      github.actor != 'dependabot[bot]' &&
      github.actor != 'github-actions[bot]'
    permissions:
      issues: write
      pull-requests: write
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@ec9f2d5744a09debf3a187a3f4f675c53b671911 # v2.13.0
        with:
          egress-policy: audit

      - name: Route to appropriate teams
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        if: github.actor != 'dependabot[bot]'
        with:
          script: |
            const issue = context.payload.issue || context.payload.pull_request;
            const title = issue.title.toLowerCase();
            const body = (issue.body || '').toLowerCase();

            // Skip template content
            const templateIndicators = ['container name(s):', 'version(s):', 'fill in details'];
            if (templateIndicators.some(indicator => body.includes(indicator.toLowerCase()))) {
              console.log('üö´ Template content detected, skipping routing');
              return;
            }

            // Conservative routing rules (very specific to avoid false positives)
            const routingRules = {
              security: {
                keywords: ['security vulnerability', 'cve-', 'security exploit', 'security issue'],
                labels: ['security', 'priority-high'],
                message: 'üîí **Security Issue** - This has been escalated to the security team.'
              },
              containers: {
                keywords: ['dockerfile bug', 'container fails', 'docker build error', 'image build issue'],
                labels: ['area/containers'],
                message: 'üê≥ **Container Issue** - The containers team has been notified.'
              }
            };

            for (const [category, rule] of Object.entries(routingRules)) {
              if (rule.keywords.some(keyword => title.includes(keyword) || body.includes(keyword))) {
                // Check if we already have this label to avoid duplicates
                const hasLabel = issue.labels.some(label => rule.labels.includes(label.name));
                if (!hasLabel) {
                  // Note: Labels are now handled by auto-label job, just add comment for routing
                  console.log(`üéØ Routing to ${category} team (labels handled by auto-label job)`);

                  // Check if we already commented to avoid spam
                  const { data: comments } = await github.rest.issues.listComments({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number
                  });

                  const hasRoutingComment = comments.some(comment => 
                    comment.user.login === 'github-actions[bot]' && 
                    (comment.body.includes('Security Issue') || comment.body.includes('Container Issue'))
                  );

                  if (!hasRoutingComment) {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: rule.message
                    });
                  }
                }
                break;
              }
            }

  # Main triage job
  triage:
    runs-on: ubuntu-latest
    name: Enhanced triage processing
    if: |
      github.event.inputs.action_type == 'triage' || 
      github.event.inputs.action_type == 'all' ||
      github.event_name == 'schedule' ||
      (github.event_name == 'workflow_dispatch' && 
       github.event.inputs.action_type != 'labeling' && 
       github.event.inputs.action_type != 'routing') ||
      (github.event_name == 'issues' && github.event.action != 'opened') ||
      (github.event_name == 'pull_request' && github.event.action != 'opened')
    # Job-level permissions for triage operations
    permissions:
      issues: write
      pull-requests: write
      contents: read
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@ec9f2d5744a09debf3a187a3f4f675c53b671911 # v2.13.0
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Validate issue template compliance
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        if: github.event_name == 'issues' && github.event.action == 'opened'
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const title = issue.title;
            const labels = [];

            // Check if issue follows template structure
            const hasEnvironmentSection = body.includes('Environment') || body.includes('environment');
            const hasStepsToReproduce = body.includes('Steps') || body.includes('reproduce');
            const hasExpectedBehavior = body.includes('Expected') || body.includes('expected');

            // Validate bug reports
            if (title.toLowerCase().includes('bug') || title.toLowerCase().includes('fix') || 
                body.toLowerCase().includes('bug') || body.toLowerCase().includes('error')) {
              if (!hasEnvironmentSection || !hasStepsToReproduce || !hasExpectedBehavior) {
                labels.push('status: needs-info');
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: `üëã Thanks for reporting this issue! 

                  It looks like this might be a bug report, but some important information is missing. To help us investigate efficiently, please provide:

                  **Missing Information:**
                  ${!hasEnvironmentSection ? '- üñ•Ô∏è **Environment details** (OS, Docker version, architecture)' : ''}
                  ${!hasStepsToReproduce ? '- üìù **Clear steps to reproduce** the issue' : ''}
                  ${!hasExpectedBehavior ? '- ‚úÖ **Expected behavior** description' : ''}

                  You can edit your issue description to add this information. Once provided, a maintainer will review your issue promptly.

                  **Tip:** Using our [issue templates](.github/ISSUE_TEMPLATE) helps ensure all necessary information is included! üìù`
                });
              } else {
                // Complete bug report gets ready status
                labels.push('status: ready');
              }
            }

            // Check for incomplete issues
            if (body.length < 50 || title.length < 10) {
              labels.push('status: needs-info');
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `üìù **More information needed**

                Your issue appears to be quite brief. To help us assist you effectively, please provide:

                - üìÑ A clear and detailed description of the issue
                - üéØ What you're trying to achieve
                - üîç What you've already tried
                - üì± Your environment details

                The more context you provide, the better we can help! üôå`
              });
            }

            // Apply labels if any
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: labels
              });
            }

      - name: Triage pull requests
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        if: github.event_name == 'pull_request' && github.actor != 'dependabot[bot]'
        with:
          script: |
            const pr = context.payload.pull_request;
            const body = pr.body || '';
            const title = pr.title;
            const labels = [];
            const comments = [];

            // Check PR description completeness
            const hasDescription = body.length > 50;
            const hasRelatedIssue = body.includes('#') || body.includes('fixes') || body.includes('closes');
            const hasTestingInfo = body.includes('test') || body.includes('Test');
            const hasChangeType = body.includes('- [x]') || body.includes('- [X]');

            if (!hasDescription) {
              labels.push('needs-info');
              comments.push(`üìù **PR Description Needed**
              
              Please provide a detailed description of your changes. A good PR description should include:
              - üéØ What problem this solves
              - üîß What changes were made
              - üß™ How it was tested
              - üìã Any breaking changes or special considerations`);
            }

            if (!hasRelatedIssue && !pr.title.toLowerCase().includes('chore')) {
              comments.push(`üîó **Link to Issue**
              
              Please link this PR to a related issue using keywords like:
              - \`Fixes #123\`
              - \`Closes #123\`
              - \`Resolves #123\`
              
              If no issue exists, consider creating one first to discuss the changes! üí≠`);
            }

            // Check for large PRs
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });

            const totalChanges = files.reduce((sum, file) => sum + file.additions + file.deletions, 0);

            if (totalChanges > 500) {
              // Note: large-pr label handled by auto-label job, just add to comments
              comments.push(`üìè **Large PR Detected**
              
              This PR has ${totalChanges} lines of changes. Large PRs can be harder to review effectively.
              
              Consider:
              - üî™ Breaking it into smaller, focused PRs
              - üìù Adding extra documentation for complex changes
              - üß™ Ensuring comprehensive testing
              
              If this size is necessary, please explain why in the PR description. ü§î`);
            }

            // Check for missing tests (if not docs/config only)
            const hasCodeChanges = files.some(file => 
              file.filename.match(/\.(js|ts|py|go|java|cpp|c|rs|php)$/));
            const hasTestChanges = files.some(file => 
              file.filename.includes('test') || file.filename.includes('spec'));

            if (hasCodeChanges && !hasTestChanges && !pr.title.toLowerCase().includes('docs')) {
              // Note: needs-tests label handled by auto-label job, just add to comments
              comments.push(`üß™ **Tests Recommended**
              
              This PR modifies code but doesn't appear to include tests. Consider adding:
              - ‚úÖ Unit tests for new functionality
              - üîç Integration tests if applicable
              - üìù Update existing tests if behavior changed
              
              If tests aren't needed, please explain why in the PR description. ü§ì`);
            }

            // Post combined comment if there are suggestions (no labels added by this job)
            if (comments.length > 0) {
              // Check if we already posted a triage comment to avoid duplicates
              const { data: existingComments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number
              });

              const hasTriageComment = existingComments.some(comment => 
                comment.user.login === 'github-actions[bot]' && 
                comment.body.includes('Automated PR Triage')
              );

              if (!hasTriageComment) {
                const combinedComment = `üëã **Automated PR Triage**

                ${comments.join('\n\n---\n\n')}

                ---
                
                üí° **Tips for faster review:**
                - Use our [PR template](.github/PULL_REQUEST_TEMPLATE.md)
                - Keep PRs focused and small when possible
                - Include tests and documentation updates
                - Link to related issues
                
                Thanks for contributing! üôè`;
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  body: combinedComment
                });
                console.log('‚úÖ Posted triage comment (no labels added)');
              } else {
                console.log('‚è≠Ô∏è Triage comment already exists, skipping');
              }
            }

      - name: Prioritize critical issues
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        if: github.event_name == 'issues'
        with:
          script: |
            const issue = context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = (issue.body || '').toLowerCase();
            const labels = [];

            // Critical issue keywords
            const criticalKeywords = [
              'critical', 'urgent', 'production', 'outage', 'down', 'broken',
              'security', 'vulnerability', 'exploit', 'cve', 'data loss'
            ];

            const highPriorityKeywords = [
              'regression', 'breaking', 'blocker', 'severe', 'major'
            ];

            // Check for critical issues
            if (criticalKeywords.some(keyword => title.includes(keyword) || body.includes(keyword))) {
              labels.push('priority-critical');
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `üö® **Critical Issue Detected**

                This issue has been automatically flagged as critical priority based on its content.
                
                **Immediate Actions:**
                - üîî Maintainers have been notified
                - ‚ö° This will be triaged with highest priority
                - üìû For urgent production issues, consider reaching out via our support channels
                
                **Next Steps:**
                - A maintainer will review within 24 hours
                - Please ensure all critical information is provided
                - Monitor for updates and respond promptly to questions
                
                Thank you for the detailed report! üôè`
              });
            } else if (highPriorityKeywords.some(keyword => title.includes(keyword) || body.includes(keyword))) {
              labels.push('priority-high');
            }

            // Apply priority labels
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: labels
              });
            }

      - name: Community health check
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        if: github.event_name == 'schedule'
        with:
          script: |
            // Find issues that need maintainer attention
            const { data: needsTriageIssues } = await github.rest.search.issuesAndPullRequests({
              q: `repo:${context.repo.owner}/${context.repo.repo} is:open is:issue -label:triaged -label:wontfix -label:duplicate created:>=${new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]}`,
              sort: 'created',
              order: 'desc',
              per_page: 10
            });

            // Find old issues without response
            const { data: staleIssues } = await github.rest.search.issuesAndPullRequests({
              q: `repo:${context.repo.owner}/${context.repo.repo} is:open is:issue comments:0 created:<${new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]}`,
              per_page: 5
            });

            if (needsTriageIssues.total_count > 0 || staleIssues.total_count > 0) {
              console.log(`üìä Triage Report:
              - ${needsTriageIssues.total_count} recent issues need triage
              - ${staleIssues.total_count} older issues have no responses
              `);
              
              // Add triage-needed label to untriaged issues
              for (const issue of needsTriageIssues.items) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['triage-needed']
                });
              }
            }

      - name: Update triage metrics
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        if: github.event_name == 'schedule'
        with:
          script: |
            // Generate triage statistics
            const now = new Date();
            const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

            const queries = {
              'new_issues': `repo:${context.repo.owner}/${context.repo.repo} is:issue created:>=${oneWeekAgo.toISOString().split('T')[0]}`,
              'new_prs': `repo:${context.repo.owner}/${context.repo.repo} is:pr created:>=${oneWeekAgo.toISOString().split('T')[0]}`,
              'triaged_issues': `repo:${context.repo.owner}/${context.repo.repo} is:issue label:triaged created:>=${oneWeekAgo.toISOString().split('T')[0]}`,
              'needs_triage': `repo:${context.repo.owner}/${context.repo.repo} is:open is:issue -label:triaged -label:wontfix`,
              'critical_open': `repo:${context.repo.owner}/${context.repo.repo} is:open is:issue label:priority-critical`
            };

            const stats = {};
            for (const [key, query] of Object.entries(queries)) {
              const { data } = await github.rest.search.issuesAndPullRequests({ q: query, per_page: 1 });
              stats[key] = data.total_count;
            }

            console.log(`üìà Weekly Triage Metrics:
            üì• New Issues: ${stats.new_issues}
            üîÑ New PRs: ${stats.new_prs}  
            ‚úÖ Triaged: ${stats.triaged_issues}
            ‚è≥ Needs Triage: ${stats.needs_triage}
            üö® Critical Open: ${stats.critical_open}

            üìä Triage Rate: ${stats.new_issues > 0 ? Math.round((stats.triaged_issues / stats.new_issues) * 100) : 0}%
            `);

            // Create issue if triage backlog is high
            if (stats.needs_triage > 20) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `üè• Triage Backlog Alert: ${stats.needs_triage} issues need attention`,
                body: `## Triage Backlog Alert

                Our issue triage backlog has grown to **${stats.needs_triage} issues** that need maintainer attention.

                ### Weekly Stats:
                - üì• New Issues: ${stats.new_issues}
                - ‚úÖ Triaged: ${stats.triaged_issues}
                - ‚è≥ Pending Triage: ${stats.needs_triage}
                - üö® Critical Issues: ${stats.critical_open}

                ### Recommended Actions:
                - [ ] Review [untriaged issues](https://github.com/${context.repo.owner}/${context.repo.repo}/issues?q=is%3Aopen+is%3Aissue+-label%3Atriaged+-label%3Awontfix)
                - [ ] Add appropriate labels and priority
                - [ ] Close duplicate or invalid issues
                - [ ] Assign issues to milestones if applicable

                This alert was automatically generated by our triage workflow.`,
                labels: ['triage-needed', 'maintenance']
              });
            }
