name: '[CI/CD] CI Pipeline'
on: # rebuild any PRs and main branch changes
  pull_request_target:
    types:
      - synchronize
      - labeled
    branches:
      - main
      - broadsage:main
  push:
    branches:
      - main
      - broadsage:main
permissions: {}
#Â Avoid concurrency over the same PR
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number }}
jobs:
  get-containers:
    runs-on: ubuntu-latest
    name: Get modified containers
    permissions:
      pull-requests: read
    if: |
      (github.event_name == 'push') ||
      (github.event_name == 'pull_request_target' && 
       github.event.pull_request.state != 'closed' &&
       (
         contains(github.event.pull_request.labels.*.name, 'verify') || (github.event.action == 'labeled' && github.event.label.name == 'verify')
       )
      )
    outputs:
      result: ${{ steps.get-containers.outputs.result }}
      containers: ${{ steps.get-containers.outputs.containers }}
      dockerfiles: ${{ steps.get-containers.outputs.dockerfiles }}
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
        name: Checkout Repository
        if: ${{ github.event_name == 'push' }}
        with:
          fetch-depth: 2
      
      - id: get-containers
        name: Get modified containers
        env:
          PULL_REQUEST_NUMBER: "${{ github.event.pull_request.number }}"
          GITHUB_TOKEN: "${{ github.token }}"
        run: |
          if [[ "${{ github.event_name }}" == "pull_request_target" ]]; then
            # For pull requests, get changed files from the PR
            files_changed="$(gh api --paginate /repos/${GITHUB_REPOSITORY}/pulls/${PULL_REQUEST_NUMBER}/files | jq -r '.[] | .filename')"
          else
            # For push events, get changed files from the commit
            files_changed="$(git diff --name-only HEAD~1 HEAD || git ls-files)"
          fi
          
          # Adding || true to avoid "Process exited with code 1" errors
          flavors=($(echo "$files_changed" | xargs dirname | grep -o "^broadsage/[^/]*/[^/]*/[^/]*" | sort | uniq || true))
          assets=($(echo "$files_changed" | xargs dirname | sed -nr "s|broadsage/([^/]*)/.*|\1|p" | sort | uniq || true))
          non_readme_files=$(echo "$files_changed" | grep -vc "\.md" || true)
          dockerfiles=($(echo "$files_changed" | grep -oE ".*/Dockerfile$" | sort | uniq || true))

          # Debug output
          echo "Changed files:"
          echo "$files_changed"
          echo "Detected flavors: ${flavors[@]}"
          echo "Detected assets: ${assets[@]}"
          echo "Non-readme files count: $non_readme_files"
          echo "Detected dockerfiles: ${dockerfiles[@]}"

          if [[ "$non_readme_files" -le "0" ]]; then
            # The only changes are .md files -> SKIP
            echo "result=skip" >> $GITHUB_OUTPUT
            echo "Reason: Only documentation files were changed"
          elif [[ "${#assets[@]}" -ge "5" ]]; then
            echo "Maximum number of assets reached. You are currently modifying: ${assets[@]}"
            echo "result=skip" >> $GITHUB_OUTPUT
            echo "Reason: Too many assets modified (${#assets[@]} >= 5)"
          elif [[ "${#flavors[@]}" -eq "0" ]]; then
            echo "No container flavors detected in changed files"
            echo "result=skip" >> $GITHUB_OUTPUT
            echo "Reason: No valid container paths found in changed files"
          else
            containers_json=$(printf "%s\n" "${flavors[@]}" | jq -R . | jq -cs .)
            dockerfiles_json=$(printf "%s\n" "${dockerfiles[@]}" | jq -R . | jq -cs .)
            echo "result=ok" >> $GITHUB_OUTPUT
            echo "containers=${containers_json}" >> $GITHUB_OUTPUT
            echo "dockerfiles=${dockerfiles_json}" >> $GITHUB_OUTPUT
            echo "Proceeding with build for ${#flavors[@]} container(s): ${flavors[@]}"
          fi
  
  build-and-test:
    runs-on: ubuntu-latest
    needs: get-containers
    if: |
      needs.get-containers.outputs.result == 'ok' &&
      (github.event_name == 'push' || (github.event.pull_request && github.event.pull_request.user.login != 'bitnami-bot'))
    name: Build and Test Docker Images
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      max-parallel: 2
      matrix:
        container: ${{ fromJSON(needs.get-containers.outputs.containers) }}
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
        name: Checkout Repository
        with:
          fetch-depth: 1
          ref: ${{ github.event_name == 'pull_request_target' && github.event.pull_request.head.ref || github.ref }}
          repository: ${{ github.event_name == 'pull_request_target' && github.event.pull_request.head.repo.full_name || github.repository }}
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - id: get-container-metadata
        name: Get image tag and container name
        run: |
          if [[ -d "${{ matrix.container }}" ]]; then
            name="$(echo "${{ matrix.container }}" | awk -F '/' '{print $2}')"
            branch="$(echo "${{ matrix.container }}" | awk -F '/' '{print $3}')"
            tag=""
            if [[ "${{ github.event_name }}" == "pull_request_target" && "${{ github.event.pull_request.user.login }}" == "bitnami-bot" ]]; then
              tag="$(grep -oE "org.opencontainers.image.ref.name=\".+\"" ${{ matrix.container }}/Dockerfile | sed -nr "s|org.opencontainers.image.ref.name=\"(.+)\"|\1|p")"
            else
              # Build a tag based on current RUN number
              tag="$(echo "${{ matrix.container }}" | awk -F '/' -v run_number="${GITHUB_RUN_NUMBER}" '{printf "%s-rc.%s", $3, run_number}')"
            fi
            if [[ -z "${tag}" ]]; then
              echo "No tag found for: ${{ matrix.container }}"
              exit 1
            else
              echo "tag=${tag}" >> $GITHUB_OUTPUT
              echo "name=${name}" >> $GITHUB_OUTPUT
              echo "branch=${branch}" >> $GITHUB_OUTPUT
              echo "image_name=ghcr.io/${{ github.repository_owner }}/${name}" >> $GITHUB_OUTPUT
              echo "result=ok" >> $GITHUB_OUTPUT
              echo "Generated tag: ${tag} for container: ${name} (branch: ${branch})"
            fi
          else
            # Container folder doesn't exist, assuming deprecation
            echo "result=skip" >> $GITHUB_OUTPUT
          fi
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        if: ${{ steps.get-container-metadata.outputs.result == 'ok' }}
        with:
          images: ${{ steps.get-container-metadata.outputs.image_name }}
          tags: |
            type=raw,value=${{ steps.get-container-metadata.outputs.tag }}
            type=raw,value=latest,enable={{is_default_branch}}
            type=ref,event=pr
      
      - name: Build Docker image
        uses: docker/build-push-action@v5
        if: ${{ steps.get-container-metadata.outputs.result == 'ok' }}
        id: build
        with:
          context: ${{ matrix.container }}
          file: ${{ matrix.container }}/Dockerfile
          push: false
          load: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Test Docker image
        if: ${{ steps.get-container-metadata.outputs.result == 'ok' }}
        run: |
          # Get the first tag from the built image
          IMAGE_TAG=$(echo "${{ steps.meta.outputs.tags }}" | head -n1)
          echo "Testing image: $IMAGE_TAG"
          
          # Basic health check - ensure container starts and stops properly
          docker run --rm --name test-container -d $IMAGE_TAG
          sleep 10
          
          # Check if container is running
          if ! docker ps | grep -q test-container; then
            echo "Container failed to start or exited unexpectedly"
            docker logs test-container || true
            exit 1
          fi
          
          # Stop the container
          docker stop test-container || true
          echo "Container test passed"
      
      - name: Security scan with Trivy
        uses: aquasecurity/trivy-action@0.24.0
        if: ${{ steps.get-container-metadata.outputs.result == 'ok' }}
        with:
          image-ref: ${{ steps.get-container-metadata.outputs.image_name }}:${{ steps.get-container-metadata.outputs.tag }}
          format: 'table'
          exit-code: '0'
          severity: 'CRITICAL,HIGH'
      
      - name: Security scan with Trivy (generate report)
        uses: aquasecurity/trivy-action@0.24.0
        if: ${{ steps.get-container-metadata.outputs.result == 'ok' }}
        with:
          image-ref: ${{ steps.get-container-metadata.outputs.image_name }}:${{ steps.get-container-metadata.outputs.tag }}
          format: 'json'
          output: 'trivy-results.json'
          exit-code: '0'
      
      - name: Security scan summary
        if: ${{ steps.get-container-metadata.outputs.result == 'ok' && always() }}
        run: |
          echo "## Security Scan Results for ${{ steps.get-container-metadata.outputs.name }}" >> $GITHUB_STEP_SUMMARY
          echo "### Image: ${{ steps.get-container-metadata.outputs.image_name }}:${{ steps.get-container-metadata.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          if [ -f "trivy-results.json" ]; then
            echo "âœ… Security scan completed successfully" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ“„ Detailed results available in workflow artifacts" >> $GITHUB_STEP_SUMMARY
            # Count vulnerabilities by severity
            critical_count=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL") | .VulnerabilityID' trivy-results.json 2>/dev/null | wc -l || echo "0")
            high_count=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity=="HIGH") | .VulnerabilityID' trivy-results.json 2>/dev/null | wc -l || echo "0")
            echo "ðŸ” **Vulnerability Summary:**" >> $GITHUB_STEP_SUMMARY
            echo "- Critical: ${critical_count}" >> $GITHUB_STEP_SUMMARY
            echo "- High: ${high_count}" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ Security scan results not found" >> $GITHUB_STEP_SUMMARY
          fi
      
      # Uncomment the following steps when GitHub Advanced Security is enabled
      # - name: Security scan with Trivy (SARIF)
      #   uses: aquasecurity/trivy-action@0.24.0
      #   if: ${{ steps.get-container-metadata.outputs.result == 'ok' }}
      #   with:
      #     image-ref: ${{ steps.get-container-metadata.outputs.image_name }}:${{ steps.get-container-metadata.outputs.tag }}
      #     format: 'sarif'
      #     output: 'trivy-results.sarif'
      # 
      # - name: Upload Trivy scan results to GitHub Security
      #   uses: github/codeql-action/upload-sarif@v3
      #   if: ${{ steps.get-container-metadata.outputs.result == 'ok' && always() }}
      #   with:
      #     sarif_file: 'trivy-results.sarif'
      #     category: 'trivy-container-scan'
      
      - name: Push Docker image (on main branch)
        uses: docker/build-push-action@v5
        if: |
          steps.get-container-metadata.outputs.result == 'ok' &&
          github.ref == 'refs/heads/main' &&
          github.event_name == 'push'
        with:
          context: ${{ matrix.container }}
          file: ${{ matrix.container }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Generate build summary
        if: ${{ steps.get-container-metadata.outputs.result == 'ok' && always() }}
        run: |
          echo "## Docker Build Summary for ${{ steps.get-container-metadata.outputs.name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Container Path**: ${{ matrix.container }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Name**: ${{ steps.get-container-metadata.outputs.image_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tag**: ${{ steps.get-container-metadata.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Status**: ${{ steps.build.outcome }}" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ github.ref }}" == "refs/heads/main" && "${{ github.event_name }}" == "push" ]]; then
            echo "- **Published**: âœ… Yes" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Published**: âŒ No (PR or non-main branch)" >> $GITHUB_STEP_SUMMARY
          fi

  build-summary:
    runs-on: ubuntu-latest
    name: Build Summary
    permissions:
      statuses: write
    needs:
      - get-containers
      - build-and-test
    outputs:
      result: ${{ steps.get-status.outputs.result }}
    if: ${{ always() && (github.event_name == 'push' || (github.event.pull_request && github.event.pull_request.user.login != 'bitnami-bot')) }}
    steps:
      - id: get-status
        name: Check Build Status
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        with:
          result-encoding: string
          script: |
            state = 'success'
            description = 'All Docker images built and tested successfully!'
            
            if ("${{ needs.get-containers.result }}" != "success" ) {
              description = "Container detection failed. Please check the workflow."
              core.warning(description)
              state = 'pending'
            } else if ("${{ needs.get-containers.outputs.result }}" == "skip" ) {
              description = "No containers to build - only documentation changes detected"
              core.notice(description)
            } else if ("${{ needs.build-and-test.result }}" != "success" ) {
              description = "Docker image build or test failed. Check the build logs for details."
              core.error(description)
              state = 'error'
            } else {
              core.notice(description)
            }
            
            // Determine the SHA to use based on the event type
            let sha;
            if (context.payload.pull_request && context.payload.pull_request.head) {
              sha = context.payload.pull_request.head.sha;
            } else if (context.payload.after) {
              // For push events
              sha = context.payload.after;
            } else if (context.sha) {
              // Fallback to context.sha
              sha = context.sha;
            } else {
              core.error("Unable to determine commit SHA for status update");
              return state;
            }
            
            try {
              await github.rest.repos.createCommitStatus({
                context: `${context.workflow} / Build Summary (${context.eventName})`,
                owner: context.payload.repository.owner.login,
                repo: context.payload.repository.name,
                sha: sha,
                target_url: `${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`,
                description: description,
                state: state
              })
              core.info(`Updated build status: ${state}`)
            } catch (error) {
              core.setFailed(error.message)
            }
            return state

  auto-pr-review:
    runs-on: ubuntu-latest
    name: Automated PR Review
    permissions:
      pull-requests: write
    needs:
      - build-summary
    if: |
      github.event_name == 'pull_request_target' &&
      github.event.pull_request &&
      contains(github.event.pull_request.labels.*.name, 'auto-merge') &&
      github.event.pull_request.user.login == 'bitnami-bot' &&
      needs.build-summary.outputs.result == 'success'
    steps:
      - name: PR Approval
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        with:
          result-encoding: string
          retries: 3
          script: |
            github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              event: 'APPROVE',
            });
      
      - name: Merge PR
        id: merge
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        with:
          result-encoding: string
          retries: 3
          github-token: ${{ secrets.BITNAMI_BOT_TOKEN }}
          script: |
            github.rest.pulls.merge({
              pull_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              merge_method: 'squash'
            })
      
      - name: Manual review required
        if: ${{ always() && steps.merge.outcome != 'success' }}
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        env:
          BODY: |
            Automated merge failed. Manual review required.
            Check the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details.
        with:
          retries: 3
          script: |
            const {BODY} = process.env
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `${BODY}`
            })
