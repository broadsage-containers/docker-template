# Copyright Broadcom, Inc. All Rights Reserved.
# SPDX-License-Identifier: APACHE-2.0

name: "[Support] Intelligent Issue Routing"

on:
  issues:
    types: [opened]
  pull_request:
    types: [opened]

# Use restrictive default permissions
permissions:
  contents: read

jobs:
  intelligent-routing:
    runs-on: ubuntu-latest
    name: Route issues to appropriate teams
    # Job-level permissions for routing operations
    permissions:
      issues: write
      pull-requests: write
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@ec9f2d5744a09debf3a187a3f4f675c53b671911 # v2.13.0
        with:
          egress-policy: audit

      - name: Analyze and route issue
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        if: github.actor != 'dependabot[bot]'
        with:
          script: |
            const issue = context.payload.issue || context.payload.pull_request;
            const isIssue = !!context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = (issue.body || '').toLowerCase();
            const labels = [];
            const comments = [];

            // Skip if this appears to be template content
            const templateIndicators = [
              'container name(s):',
              'version(s):',
              'base image:',
              'architecture(s):',
              'fill in details',
              'mark all relevant options',
              'provide a brief description',
              'change 1',
              'change 2',
              'change 3'
            ];
            
            const isTemplate = templateIndicators.some(indicator => 
              body.includes(indicator.toLowerCase())
            );
            
            if (isTemplate) {
              console.log('ðŸš« Template content detected, skipping intelligent routing to avoid false positives');
              return;
            }

            // Content analysis rules for automatic routing (more conservative)
            const routingRules = {
              // Container and Docker related - only for specific mentions
              'container': {
                keywords: ['dockerfile bug', 'container fails', 'docker build error', 'image issue', 'registry problem'],
                labels: ['area/containers'],
                team: 'containers-team',
                message: 'ðŸ³ **Container/Docker Issue Detected**\n\nThis appears to be related to containers or Docker. The containers team has been notified.'
              },
              
              // Security related - only for actual security issues
              'security': {
                keywords: ['security vulnerability', 'cve-', 'security patch', 'exploit found', 'malicious code', 'unauthorized access'],
                labels: ['security', 'priority-high'],
                team: 'security-team',
                message: 'ðŸ”’ **Security Issue Detected**\n\nThis has been flagged as a security-related issue and escalated to the security team.'
              },
              
              // Build and CI/CD - only for actual build failures
              'build': {
                keywords: ['build fails', 'compile error', 'ci failure', 'pipeline broken', 'workflow error'],
                labels: ['area/build'],
                team: 'devops-team',
                message: 'ðŸ”¨ **Build/CI Issue Detected**\n\nThis appears to be related to builds or CI/CD. The DevOps team has been notified.'
              }
            };

            // Analyze content and apply rules (only one rule per issue)
            let matchedCategory = null;
            for (const [category, rule] of Object.entries(routingRules)) {
              const hasKeyword = rule.keywords.some(keyword => 
                title.includes(keyword) || body.includes(keyword)
              );
              
              if (hasKeyword) {
                matchedCategory = category;
                labels.push(...rule.labels);
                comments.push(rule.message);
                break; // Apply only the first matching rule
              }
            }

            // Platform detection - only if explicitly mentioned in context of issues
            const platformKeywords = {
              'platform/linux': ['linux error', 'ubuntu issue', 'debian problem'],
              'platform/windows': ['windows error', 'win32 issue', 'windows problem'],
              'platform/macos': ['macos error', 'mac os issue', 'darwin problem'],
            };

            // Only add platform labels if there's an actual platform-specific issue
            if (matchedCategory) {
              for (const [platformLabel, keywords] of Object.entries(platformKeywords)) {
                if (keywords.some(keyword => title.includes(keyword) || body.includes(keyword))) {
                  labels.push(platformLabel);
                  break; // Only one platform per issue
                }
              }
            }

            // Severity assessment - only for clear severity indicators
            const severityKeywords = {
              'severity/critical': ['production down', 'critical outage', 'data loss', 'system crashed'],
              'severity/high': ['major regression', 'severe impact', 'blocking issue'],
            };

            for (const [severityLabel, keywords] of Object.entries(severityKeywords)) {
              if (keywords.some(keyword => title.includes(keyword) || body.includes(keyword))) {
                labels.push(severityLabel);
                break; // Only one severity level
              }
            }

            // Apply labels
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: [...new Set(labels)] // Remove duplicates
              });
            }

            // Post routing information
            if (comments.length > 0) {
              const routingComment = `ðŸ¤– **Automated Issue Routing**

              ${comments.join('\n\n')}

              **Applied Labels:** ${labels.length > 0 ? labels.map(l => `\`${l}\``).join(', ') : 'None'}

              ${matchedCategory ? `**Routing Category:** \`${matchedCategory}\`` : ''}

              ---
              
              ðŸ’¡ **Next Steps:**
              - A team member will review this issue
              - You may be asked for additional information
              - Check back for updates and respond promptly

              *This routing was performed automatically. If you believe this is incorrect, please let us know!*`;
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: routingComment
              });
            }

            // Log routing decision
            console.log(`ðŸ“Š Issue Routing Summary:
            - Issue: #${issue.number}
            - Category: ${matchedCategory || 'unclassified'}
            - Labels Applied: ${labels.join(', ') || 'none'}
            - Auto-routed: ${comments.length > 0 ? 'yes' : 'no'}
            `);

      - name: Handle duplicate detection
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        if: github.event_name == 'issues' && github.actor != 'dependabot[bot]'
        with:
          script: |
            const issue = context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = (issue.body || '').toLowerCase();

            // Search for similar issues
            const searchQuery = `repo:${context.repo.owner}/${context.repo.repo} is:issue "${title.slice(0, 50)}"`;

            try {
              const { data: similarIssues } = await github.rest.search.issuesAndPullRequests({
                q: searchQuery,
                sort: 'created',
                order: 'desc',
                per_page: 5
              });
              
              // Filter out the current issue and check for potential duplicates
              const otherIssues = similarIssues.items.filter(item => item.number !== issue.number);
              
              if (otherIssues.length > 0) {
                const duplicateCheck = `ðŸ” **Potential Duplicate Check**

                I found ${otherIssues.length} similar issue(s) that might be related:

                ${otherIssues.map((item, index) => 
                  `${index + 1}. #${item.number} - [${item.title}](${item.html_url}) ${item.state === 'closed' ? '(Closed)' : '(Open)'}`
                ).join('\n')}

                **Please check if any of these issues are duplicates before proceeding.**

                If this is indeed a duplicate:
                - Reference the original issue in a comment
                - Close this issue with the \`duplicate\` label

                If this is a new issue:
                - Provide additional context that differentiates it
                - Reference related issues for context

                *This check was performed automatically to help maintain a clean issue tracker.*`;
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: duplicateCheck
                });
              }
            } catch (error) {
              console.log(`Could not perform duplicate check: ${error.message}`);
            }
